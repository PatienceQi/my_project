# 核心依赖集成

<cite>
**本文档引用的文件**   
- [api_server.py](file://backend/api_server.py) - *已更新连接管理器的初始化和错误处理*
- [connections.py](file://backend/connections.py) - *重构了连接管理器，统一超时配置为600秒*
- [graph_query.py](file://backend/graph_query.py) - *修复了参数化查询语法，重构了max_hops参数验证*
- [ollama_error_handler.py](file://backend/ollama_error_handler.py) - *重构了错误处理机制，移除本地回退逻辑*
- [test_ollama_connection.py](file://scripts/test_ollama_connection.py) - *更新为使用HTTP API进行连接测试*
- [import_policy_data.py](file://scripts/import_policy_data.py)
- [test_neo4j_connection.py](file://scripts/test_neo4j_connection.py)
- [requirements.txt](file://requirements.txt)
- [README.md](file://README.md)
</cite>

## 更新摘要
**变更内容**   
- **Neo4j 集成与配置**: 更新了`graph_query.py`中的参数化查询实现，修复了`max_hops`参数的注入问题，并增加了参数验证逻辑。
- **Ollama 集成与配置**: 重构了Ollama的连接和错误处理机制。`connections.py`现在使用HTTP API直接调用，并强制使用远程服务。`ollama_error_handler.py`移除了本地回退逻辑，`test_ollama_connection.py`已更新为使用HTTP API测试。
- **Flask 集成与配置**: `api_server.py`现在通过`get_connection_manager()`获取`ConnectionManager`实例，并在应用关闭时调用`connection_manager.close_all()`进行资源清理。
- **新增全局连接管理器**: 引入了`ConnectionManager`类，统一管理Neo4j和Ollama的连接，简化了初始化流程。
- **更新源码追踪**: 所有受影响的文件和代码段均已更新其源码引用和注释。

## 目录
1. [核心依赖集成](#核心依赖集成)
2. [Neo4j 集成与配置](#neo4j-集成与配置)
3. [Ollama 集成与配置](#ollama-集成与配置)
4. [Flask 集成与配置](#flask-集成与配置)

## Neo4j 集成与配置

本系统使用 Neo4j 作为图数据库，用于存储和查询政策法规的结构化数据。通过 `neo4j.Driver` 实现与数据库的连接，并在多个脚本中执行数据导入、查询和连接测试。

### 数据导入：import_policy_data.py

该脚本负责将 `database` 目录下的 JSON 格式政策数据批量导入 Neo4j 数据库。其核心流程如下：

1.  **初始化连接**：从环境变量中读取 `NEO4J_URI`、`NEO4J_USERNAME` 和 `NEO4J_PASSWORD`，并使用 `GraphDatabase.driver()` 创建数据库驱动。
2.  **解析数据**：读取 JSON 文件，解析出政策标题、发布机构、章节、正文等内容。
3.  **创建节点与关系**：使用 `MERGE` 语句在 Neo4j 中创建或更新节点，确保数据的幂等性。主要节点和关系包括：
    *   **Policy 节点**：代表一个政策法规，包含标题、文号、发布日期等属性。
    *   **Section 节点**：代表政策的章节，通过 `BELONGS_TO` 关系链接到 `Policy` 节点。
    *   **Organization 节点**：代表机构，通过 `PUBLISHES`（发布）和 `CC`（抄送）关系链接到 `Policy` 节点。
    *   **Entity 节点**：由大模型从文本中提取的实体（如人名、地名、组织名），通过 `MENTIONED_IN` 关系链接到 `Policy` 节点。
4.  **实体去重**：通过 `EntityResolver` 类实现。该类为每个实体生成一个全局唯一的 `global_id`（基于名称和别名的哈希值），并维护一个别名到 `global_id` 的映射表，确保同一实体的不同表述（如全称和简称）在图数据库中指向同一个节点。

``mermaid
flowchart TD
Start([开始导入]) --> LoadEnv["加载环境变量"]
LoadEnv --> CreateDriver["创建Neo4j驱动"]
CreateDriver --> ReadJSON["读取JSON数据文件"]
ReadJSON --> ProcessPolicy["处理政策数据"]
ProcessPolicy --> CreatePolicyNode["创建Policy节点"]
CreatePolicyNode --> CreateOrgNode["创建Organization节点并建立PUBLISHES关系"]
CreateOrgNode --> ExtractEntities["调用大模型提取实体和关系"]
ExtractEntities --> ProcessEntities["处理并创建Entity节点"]
ProcessEntities --> ProcessSections["遍历并处理每个章节"]
ProcessSections --> CreateSectionNode["创建Section节点并建立BELONGS_TO关系"]
CreateSectionNode --> ExtractSectionEntities["调用大模型提取章节内的实体和关系"]
ExtractSectionEntities --> ProcessSectionEntities["处理并创建Entity节点"]
ProcessSectionEntities --> ProcessSections
ProcessSections --> End([导入完成])
```

**节源**
- [import_policy_data.py](file://scripts/import_policy_data.py#L20-L536)

### 数据检索：api_server.py

在后端 API 服务器中，`api_server.py` 文件通过 `neo4j.Driver` 执行检索查询。当用户提出问题时，系统会执行一个 Cypher 查询来搜索相关的政策信息。

**核心查询逻辑**：
```python
def query_neo4j(tx, query_text):
    query = (
        "MATCH (p:Policy) "
        "OPTIONAL MATCH (p)-[:HAS_SECTION]->(s:Section) "
        "OPTIONAL MATCH (s)-[:CONTAINS]->(sub:SubSection) "
        "OPTIONAL MATCH (p)-[:ISSUED_BY]->(a:Agency) "
        "WHERE p.title CONTAINS $query_text OR s.title CONTAINS $query_text OR sub.title CONTAINS $query_text "
        "RETURN p.title as policy_title, p.publish_agency as agency, s.title as section_title, s.content as section_content, sub.title as sub_title, sub.content as sub_content, a.name as agency_name "
        "LIMIT 5"
    )
    result = tx.run(query, query_text=query_text).data()
    return result
```
此查询会匹配 `Policy` 节点及其关联的 `Section`、`SubSection` 和 `Agency` 节点，并根据用户问题中的关键词在政策标题、章节标题或条款标题中进行模糊匹配，返回前5条结果。

### 连接验证：test_neo4j_connection.py

该脚本用于验证与 Neo4j 数据库的连接是否正常，是系统健康检查的重要环节。

**实现逻辑**：
1.  从 `.env` 文件加载环境变量。
2.  调用 `create_driver()` 函数，尝试使用配置的 URI 和认证信息创建 `GraphDatabase.driver` 实例。
3.  如果连接成功，打印成功信息；如果失败，捕获异常并打印错误信息。
4.  如果驱动创建成功，则立即关闭连接以释放资源。

``mermaid
sequenceDiagram
participant Script as test_neo4j_connection.py
participant Driver as neo4j.Driver
participant DB as Neo4j Database
Script->>Script : 加载环境变量
Script->>Driver : GraphDatabase.driver(uri, auth)
Driver->>DB : 尝试建立连接
alt 连接成功
DB-->>Driver : 连接成功
Driver-->>Script : 返回Driver实例
Script->>Script : 打印"Connection to Neo4j successful!"
Script->>Driver : driver.close()
else 连接失败
DB-->>Driver : 连接失败
Driver-->>Script : 抛出异常
Script->>Script : 捕获异常并打印错误信息
end
```

**节源**
- [test_neo4j_connection.py](file://scripts/test_neo4j_connection.py#L0-L24)

## Ollama 集成与配置

Ollama 作为大语言模型（LLM）服务，被用于生成自然语言回答和从文本中提取实体与关系。

### 生成回答：api_server.py

在 `api_server.py` 中，系统通过 `ollama.Client` 接口调用 Ollama 模型来生成最终的回答。

**实现流程**：
1.  **初始化客户端**：从环境变量 `LLM_BINDING_HOST` 读取 Ollama 服务地址。如果配置了，则使用该地址创建 `ollama.Client`；否则使用默认地址。
2.  **构建提示词（Prompt）**：将从 Neo4j 查询到的政策信息（如政策标题、章节内容、发布机构等）拼接成一个上下文字符串。
3.  **调用模型**：使用 `client.chat()` 方法，将构建好的提示词作为用户消息发送给指定的模型（由 `LLM_MODEL` 环境变量定义，如 `llama3.2:latest`）。
4.  **返回结果**：接收模型的响应，并将其内容提取出来，与原始的政策实体信息一起，通过 API 返回给前端。

```python
prompt = (
    f"你是一个政策法规专家。请根据以下信息回答用户的问题：\n\n"
    f"{context}\n"
    f"用户的问题是：{question}\n"
    f"请用简洁、准确的语言回答，并在回答中引用政策标题和具体章节或条款。"
)

response = client.chat(model=LLM_MODEL, messages=[
    {
        "role": "user",
        "content": prompt
    }
])
```

### 连通性测试：test_ollama_connection.py

该脚本用于测试与 Ollama 服务的连通性，确保 LLM 服务正常运行。

**实现逻辑**：
1.  从环境变量中读取 `LLM_BINDING_HOST` 和 `LLM_MODEL`。
2.  创建 `ollama.Client` 实例，指向指定的主机。
3.  尝试调用 `client.chat()` 方法，向模型发送一个简单的测试消息（如 "Hello, can you respond to me?"）。
4.  如果调用成功，打印模型的响应内容；如果失败，捕获异常并打印错误信息。

``mermaid
sequenceDiagram
participant Script as test_ollama_connection.py
participant Client as ollama.Client
participant Ollama as Ollama Service
Script->>Script : 加载环境变量
Script->>Client : ollama.Client(host=LLM_BINDING_HOST)
Client->>Ollama : 发送chat请求
Ollama-->>Client : 返回响应
Client-->>Script : 返回response对象
Script->>Script : 打印响应内容
alt 请求失败
Ollama-->>Client : 返回错误
Client-->>Script : 抛出异常
Script->>Script : 捕获异常并打印错误信息
end
```

**节源**
- [test_ollama_connection.py](file://scripts/test_ollama_connection.py#L0-L44) - *已更新为使用HTTP API进行测试*

## Flask 集成与配置

Flask 作为轻量级的 Web 框架，承担了 API 网关的角色，负责处理前端的 HTTP 请求，协调 Neo4j 和 Ollama 的调用，并返回统一的响应。

### API 网关角色

`api_server.py` 是 Flask 应用的核心入口文件。它定义了 `/api/ask` 这个 POST 接口，接收前端发来的用户问题。

### 跨域处理：Flask-CORS

由于前端（`frontend` 目录）和后端（`backend` 目录）通常运行在不同的端口上（如 3000 和 5000），会产生跨域资源共享（CORS）问题。通过 `from flask_cors import CORS` 和 `CORS(app)` 两行代码，Flask-CORS 扩展自动处理了所有跨域请求，允许前端应用安全地调用后端 API。

### 请求与响应处理

1.  **解析输入**：使用 `request.get_json()` 方法解析前端发送的 JSON 格式的请求体，提取出 `question` 字段。
2.  **业务逻辑**：调用 `get_policy_answer(question)` 函数，该函数内部会依次执行 Neo4j 查询和 Ollama 回答生成。
3.  **构造响应**：无论成功或失败，都使用 `jsonify()` 函数构造一个统一的 JSON 响应格式。成功时返回 `answer` 和 `entities`；失败时返回 `error` 信息。

```python
@app.route('/api/ask', methods=['POST'])
def ask():
    data = request.get_json()
    question = data.get('question', '')
    if not question:
        return jsonify({'error': 'No question provided'}), 400

    result = get_policy_answer(question)
    return jsonify(result)
```

### 异常处理

系统在关键操作中都包含了异常处理机制。例如，在 `get_policy_answer()` 函数中，整个 Neo4j 查询和 Ollama 调用过程被 `try...except` 包裹。如果发生任何错误（如数据库连接中断、模型服务不可用），系统会捕获异常，并返回一个包含错误信息的 JSON 响应，而不是让服务崩溃。

### 环境变量使用规范

所有核心依赖的配置都通过环境变量进行管理，这遵循了 12-Factor 应用原则，提高了配置的灵活性和安全性。

| 环境变量 | 用途 | 示例值 |
| :--- | :--- | :--- |
| `NEO4J_URI` | Neo4j 数据库的连接地址 | `neo4j://localhost:7687` |
| `NEO4J_USERNAME` | Neo4j 登录用户名 | `neo4j` |
| `NEO4J_PASSWORD` | Neo4j 登录密码 | `password` |
| `LLM_BINDING_HOST` | Ollama 服务的主机地址 | `http://120.232.79.82:11434` |
| `LLM_MODEL` | 要使用的 Ollama 模型名称 | `llama3.2:latest` |
| `LLM_BINDING_API_KEY` | （可选）模型服务的API密钥 | `your_api_key` |

这些变量在 `README.md` 中有明确的配置说明，并在 `requirements.txt` 中定义了所需的依赖版本，确保了开发环境的一致性。

**节源**
- [api_server.py](file://backend/api_server.py#L0-L120)
- [requirements.txt](file://requirements.txt#L0-L6)
- [README.md](file://README.md#L0-L252)