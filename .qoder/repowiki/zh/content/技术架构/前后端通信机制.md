# 前后端通信机制

<cite>
**本文档引用的文件**  
- [index.html](file://frontend/index.html#L0-L253)
- [api_server.py](file://backend/api_server.py#L0-L119)
- [requirements.txt](file://requirements.txt#L0-L6)
</cite>

## 目录
1. [前后端通信机制](#前后端通信机制)
2. [前端请求实现](#前端请求实现)
3. [后端API处理](#后端api处理)
4. [请求与响应示例](#请求与响应示例)
5. [连接状态与错误处理](#连接状态与错误处理)
6. [通信架构特性](#通信架构特性)

## 前端请求实现

前端通过 `fetch` API 向后端 Flask 服务发起 HTTP 请求，实现与后端的通信。核心通信逻辑位于 `frontend/index.html` 文件中，主要通过 JavaScript 实现。

前端定义了后端 API 的访问地址：
```javascript
const backendUrl = 'http://127.0.0.1:5000/api/ask';
```

当用户在输入框中输入问题并点击“发送”按钮或按下回车键时，`sendMessage()` 函数被触发。该函数首先检查与后端的连接状态，若连接正常，则通过 `fetch` 方法向 `/api/ask` 端点发送 POST 请求。

请求配置如下：
- **方法**: `POST`
- **请求头**: 设置 `Content-Type` 为 `application/json`
- **请求体**: 将用户问题包装为 JSON 对象 `{ "question": "用户输入的问题" }`
- **模式**: 显式设置 `mode: 'cors'` 以支持跨域请求

```javascript
const response = await fetch(backendUrl, {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({ question }),
});
```

前端通过事件监听器绑定用户交互：
```javascript
document.getElementById('userInput').addEventListener('keypress', function (e) {
    if (e.key === 'Enter') {
        sendMessage();
    }
});
document.getElementById('sendButton').addEventListener('click', sendMessage);
```

**Section sources**
- [index.html](file://frontend/index.html#L192-L207)

## 后端API处理

后端使用 Flask 框架构建 RESTful API，核心逻辑位于 `backend/api_server.py` 文件中。后端通过定义路由 `/api/ask` 处理前端的 POST 请求。

### 跨域请求处理
为支持前端跨域访问，后端使用 `flask-cors` 扩展启用 CORS（跨域资源共享）：
```python
from flask_cors import CORS
app = Flask(__name__)
CORS(app)
```
此配置允许来自不同源（如前端运行在 `http://localhost:3000`）的请求访问后端服务（运行在 `http://127.0.0.1:5000`），无需额外配置。

### 请求处理流程
`/api/ask` 路由的处理函数 `ask()` 执行以下步骤：
1. 解析 JSON 请求体：`data = request.get_json()`
2. 提取问题文本：`question = data.get('question', '')`
3. 验证输入：若问题为空，返回 400 错误
4. 调用 `get_policy_answer(question)` 函数生成回答
5. 将结果以 JSON 格式返回：`jsonify(result)`

```python
@app.route('/api/ask', methods=['POST'])
def ask():
    data = request.get_json()
    question = data.get('question', '')
    if not question:
        return jsonify({'error': 'No question provided'}), 400

    result = get_policy_answer(question)
    return jsonify(result)
```

### 回答生成逻辑
`get_policy_answer()` 函数是核心业务逻辑，其工作流程如下：
1. 连接 Neo4j 图数据库，执行 Cypher 查询，根据问题关键词检索相关政策、章节和发布机构。
2. 将检索到的结果拼接成上下文字符串 `context`。
3. 调用 Ollama 大语言模型 API，将 `context` 和用户问题作为提示（prompt）发送，生成自然语言回答。
4. 构造包含 `answer` 和 `entities` 字段的响应对象。

```python
return {
    "answer": response['message']['content'],
    "entities": results
}
```

**Section sources**
- [api_server.py](file://backend/api_server.py#L108-L119)
- [api_server.py](file://backend/api_server.py#L46-L106)

## 请求与响应示例

### 请求示例
前端向 `http://127.0.0.1:5000/api/ask` 发送的 POST 请求：
```json
{
  "question": "华侨试验区有哪些税收优惠政策？"
}
```

### 成功响应示例
后端返回的 JSON 响应：
```json
{
  "answer": "根据《华侨经济文化合作试验区税收优惠政策》，试验区内的高新技术企业可享受15%的企业所得税优惠税率。此外，对符合条件的跨境服务贸易实行增值税免税政策。",
  "entities": [
    {
      "policy_title": "华侨经济文化合作试验区税收优惠政策",
      "section_title": "第二章 企业所得税优惠",
      "content": "对注册在试验区内的高新技术企业，减按15%的优惠税率征收企业所得税。",
      "agency": "国家税务总局",
      "relation": "发布单位"
    },
    {
      "policy_title": "华侨经济文化合作试验区税收优惠政策",
      "section_title": "第五章 增值税政策",
      "content": "对试验区内的企业从事符合条件的跨境服务贸易，免征增值税。",
      "agency": "国家税务总局",
      "relation": "发布单位"
    }
  ]
}
```

### 前端解析与展示
前端接收到响应后，解析 JSON 数据并动态更新页面：
- **回答内容**: 使用 `data.answer` 并将换行符 `\n` 替换为 `<br>` 进行展示。
- **相关法规**: 遍历 `data.entities` 数组，创建无序列表 `<ul>`，展示政策标题、章节和发布单位。

```javascript
botMsg.innerHTML = `<strong>回答:</strong> ${data.answer.replace(/\n/g, '<br>')}`;
if (data.entities && data.entities.length > 0) {
    botMsg.innerHTML += `<br><strong>相关政策法规:</strong>`;
    const entityList = document.createElement('ul');
    data.entities.forEach(entity => {
        const listItem = document.createElement('li');
        listItem.innerHTML = `<strong>${entity.policy_title}</strong> - ${entity.section_title} （发布单位: ${entity.agency}）`;
        entityList.appendChild(listItem);
    });
    botMsg.appendChild(entityList);
}
```

**Section sources**
- [index.html](file://frontend/index.html#L205-L228)

## 连接状态与错误处理

### 连接状态检测
前端实现了自动化的后端连接状态检测机制。通过 `setInterval` 每 5 秒执行一次 `updateConnectionStatus()` 函数。

该函数向 `/api/ask` 端点发送一个测试请求（问题为 "test"），根据响应结果更新页面右上角的状态指示器：
- **响应成功**: 状态显示为“已连接”，背景色为绿色。
- **响应失败或异常**: 状态显示为“未连接”，背景色为红色。

```javascript
function updateConnectionStatus() {
    fetch('http://127.0.0.1:5000/api/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question: 'test' }),
        mode: 'cors'
    })
    .then(response => {
        if (response.ok) {
            isConnected = true;
            statusElement.textContent = '已连接';
            statusElement.className = 'status connected';
        } else {
            // ... 处理未连接状态
        }
    })
    .catch(() => {
        // ... 处理网络异常
    });
}
```

**Section sources**
- [index.html](file://frontend/index.html#L130-L164)

### 错误处理机制
前端和后端均实现了完善的错误处理：

**前端错误处理**:
- **连接中断**: 在 `sendMessage()` 函数中检查 `isConnected` 标志，若未连接则直接在聊天框中显示错误提示。
- **HTTP错误**: 在 `fetch` 调用中使用 `try-catch` 捕获异常，若 `response.ok` 为 `false` 或发生网络错误，则在聊天框中显示“抱歉，发生了一个错误，请稍后再试。”。

```javascript
async function sendMessage() {
    if (!isConnected) {
        // ... 显示连接错误
        return;
    }
    try {
        // ... 发送请求
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        // ... 处理成功响应
    } catch (error) {
        console.error('Error:', error);
        // ... 显示通用错误消息
    }
}
```

**后端错误处理**:
- **输入验证**: 检查 `question` 字段是否存在，若缺失则返回 400 错误。
- **内部异常**: `get_policy_answer()` 函数使用 `try-except` 捕获数据库或模型调用过程中的任何异常，确保返回格式一致的 JSON 响应，避免服务崩溃。

```python
def get_policy_answer(question):
    try:
        # ... 业务逻辑
    except Exception as e:
        return {
            "answer": f"查询过程中出现错误: {str(e)}",
            "entities": []
        }
```

**Section sources**
- [index.html](file://frontend/index.html#L162-L193)
- [index.html](file://frontend/index.html#L230-L253)
- [api_server.py](file://backend/api_server.py#L46-L106)

## 通信架构特性

### 无状态RESTful通信
本系统采用无状态的 RESTful 风格进行前后端通信。所有关键信息（即用户问题）都通过单次 HTTP 请求的请求体传递，后端不依赖任何会话（Session）来保持客户端状态。

分析代码库，未发现使用 Flask 的 `session` 对象进行用户状态管理。代码中出现的 `session` 均指 Neo4j 数据库的会话（`driver.session()`），与 HTTP 会话无关：
```python
with driver.session() as session: # 这是Neo4j数据库会话
    neo4j_results = session.read_transaction(query_neo4j, question)
```

这种无状态设计具有以下优势：
- **可扩展性**: 由于每个请求都包含所有必要信息，服务器可以轻松地进行水平扩展，添加更多实例来处理高并发请求，而无需复杂的会话同步机制。
- **简单性**: 通信逻辑清晰，易于理解和维护。
- **可靠性**: 单个请求的失败不会影响其他请求，系统整体更健壮。

### 响应格式一致性
后端通过以下方式确保响应格式的一致性：
1. **统一返回结构**: 无论成功、失败还是未找到结果，`get_policy_answer()` 函数始终返回包含 `answer` 和 `entities` 字段的字典。
2. **异常捕获**: 使用 `try-except` 块包裹核心逻辑，确保即使发生内部错误，也能返回预定义格式的错误信息，而非未处理的异常。
3. **使用 jsonify**: Flask 的 `jsonify()` 函数确保返回的响应具有正确的 `Content-Type: application/json` 头，并将 Python 字典安全地序列化为 JSON。

### 依赖关系
项目依赖通过 `requirements.txt` 文件明确管理，关键依赖包括：
- `flask==3.0.0`: Web 服务框架
- `flask-cors==4.0.0`: 跨域资源共享支持
- `ollama==0.5.3`: 大语言模型 API 客户端
- `neo4j==5.14.1`: 图数据库驱动
- `python-dotenv==1.0.0`: 环境变量加载

**Section sources**
- [api_server.py](file://backend/api_server.py#L0-L44)
- [requirements.txt](file://requirements.txt#L0-L6)